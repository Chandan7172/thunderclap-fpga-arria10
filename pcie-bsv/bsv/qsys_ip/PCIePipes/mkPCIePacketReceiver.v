//
// Generated by Bluespec Compiler, version 2017.07.A (build 1da80f1, 2017-07-21)
//
// On Wed Jan  2 22:34:26 GMT 2019
//
//
// Ports:
// Name                         I/O  size props
// streamSink_asi_ready           O     1
// mmSlave_avs_readdata           O    64
// mmSlave_avs_readdatavalid      O     1 reg
// mmSlave_avs_waitrequest        O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// streamSink_asi_data            I    64 reg
// streamSink_asi_valid           I     1
// streamSink_asi_sop             I     1 reg
// streamSink_asi_eop             I     1 reg
// streamSink_asi_be              I     8 reg
// streamSink_asi_parity          I     8 unused
// streamSink_asi_bar             I     8 unused
// mmSlave_avs_writedata          I    64 reg
// mmSlave_avs_address            I     8 reg
// mmSlave_avs_read               I     1
// mmSlave_avs_write              I     1
// mmSlave_avs_byteenable         I     8 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkPCIePacketReceiver(CLK,
			    RST_N,

			    streamSink_asi_data,
			    streamSink_asi_valid,
			    streamSink_asi_sop,
			    streamSink_asi_eop,
			    streamSink_asi_be,
			    streamSink_asi_parity,
			    streamSink_asi_bar,

			    streamSink_asi_ready,

			    mmSlave_avs_readdata,

			    mmSlave_avs_readdatavalid,

			    mmSlave_avs_waitrequest,

			    mmSlave_avs_writedata,
			    mmSlave_avs_address,
			    mmSlave_avs_read,
			    mmSlave_avs_write,
			    mmSlave_avs_byteenable);
  input  CLK;
  input  RST_N;

  // action method streamSink_asi
  input  [63 : 0] streamSink_asi_data;
  input  streamSink_asi_valid;
  input  streamSink_asi_sop;
  input  streamSink_asi_eop;
  input  [7 : 0] streamSink_asi_be;
  input  [7 : 0] streamSink_asi_parity;
  input  [7 : 0] streamSink_asi_bar;

  // value method streamSink_asi_ready
  output streamSink_asi_ready;

  // value method mmSlave_avs_readdata
  output [63 : 0] mmSlave_avs_readdata;

  // value method mmSlave_avs_readdatavalid
  output mmSlave_avs_readdatavalid;

  // value method mmSlave_avs_waitrequest
  output mmSlave_avs_waitrequest;

  // action method mmSlave_avs
  input  [63 : 0] mmSlave_avs_writedata;
  input  [7 : 0] mmSlave_avs_address;
  input  mmSlave_avs_read;
  input  mmSlave_avs_write;
  input  [7 : 0] mmSlave_avs_byteenable;

  // signals for module outputs
  wire [63 : 0] mmSlave_avs_readdata;
  wire mmSlave_avs_readdatavalid,
       mmSlave_avs_waitrequest,
       streamSink_asi_ready;

  // register currentpcieword
  reg [80 : 0] currentpcieword;
  wire [80 : 0] currentpcieword$D_IN;
  wire currentpcieword$EN;

  // register dwordCounter
  reg [9 : 0] dwordCounter;
  wire [9 : 0] dwordCounter$D_IN;
  wire dwordCounter$EN;

  // register fourDWord
  reg fourDWord;
  wire fourDWord$D_IN, fourDWord$EN;

  // register next
  reg next;
  wire next$D_IN, next$EN;

  // ports of submodule rxfifo
  wire [80 : 0] rxfifo$D_IN, rxfifo$D_OUT;
  wire rxfifo$CLR, rxfifo$DEQ, rxfifo$EMPTY_N, rxfifo$ENQ, rxfifo$FULL_N;

  // ports of submodule slave_req
  wire [80 : 0] slave_req$D_IN, slave_req$D_OUT;
  wire slave_req$CLR,
       slave_req$DEQ,
       slave_req$EMPTY_N,
       slave_req$ENQ,
       slave_req$FULL_N;

  // ports of submodule streamToFIFO_queue
  wire [80 : 0] streamToFIFO_queue$D_IN, streamToFIFO_queue$D_OUT;
  wire streamToFIFO_queue$CLR,
       streamToFIFO_queue$DEQ,
       streamToFIFO_queue$EMPTY_N,
       streamToFIFO_queue$ENQ,
       streamToFIFO_queue$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_fetchpcieword,
       CAN_FIRE_RL_nextprint,
       CAN_FIRE_RL_serviceMMSlave,
       CAN_FIRE_mmSlave_avs,
       CAN_FIRE_streamSink_asi,
       WILL_FIRE_RL_fetchpcieword,
       WILL_FIRE_RL_nextprint,
       WILL_FIRE_RL_serviceMMSlave,
       WILL_FIRE_mmSlave_avs,
       WILL_FIRE_streamSink_asi;

  // remaining internal signals
  reg [63 : 0] v__h733;
  wire [63 : 0] response__h892, response__h902;

  // action method streamSink_asi
  assign CAN_FIRE_streamSink_asi = 1'd1 ;
  assign WILL_FIRE_streamSink_asi = 1'd1 ;

  // value method streamSink_asi_ready
  assign streamSink_asi_ready = streamToFIFO_queue$FULL_N ;

  // value method mmSlave_avs_readdata
  assign mmSlave_avs_readdata =
	     slave_req$D_OUT[80] ? 64'hFEEB1EC0FFEEFEED : v__h733 ;

  // value method mmSlave_avs_readdatavalid
  assign mmSlave_avs_readdatavalid = slave_req$EMPTY_N ;

  // value method mmSlave_avs_waitrequest
  assign mmSlave_avs_waitrequest = !slave_req$FULL_N ;

  // action method mmSlave_avs
  assign CAN_FIRE_mmSlave_avs = 1'd1 ;
  assign WILL_FIRE_mmSlave_avs = 1'd1 ;

  // submodule rxfifo
  SizedFIFO #(.p1width(32'd81),
	      .p2depth(32'd1024),
	      .p3cntr_width(32'd10),
	      .guarded(32'd0)) rxfifo(.RST(RST_N),
				      .CLK(CLK),
				      .D_IN(rxfifo$D_IN),
				      .ENQ(rxfifo$ENQ),
				      .DEQ(rxfifo$DEQ),
				      .CLR(rxfifo$CLR),
				      .D_OUT(rxfifo$D_OUT),
				      .FULL_N(rxfifo$FULL_N),
				      .EMPTY_N(rxfifo$EMPTY_N));

  // submodule slave_req
  FIFOL1 #(.width(32'd81)) slave_req(.RST(RST_N),
				     .CLK(CLK),
				     .D_IN(slave_req$D_IN),
				     .ENQ(slave_req$ENQ),
				     .DEQ(slave_req$DEQ),
				     .CLR(slave_req$CLR),
				     .D_OUT(slave_req$D_OUT),
				     .FULL_N(slave_req$FULL_N),
				     .EMPTY_N(slave_req$EMPTY_N));

  // submodule streamToFIFO_queue
  FIFOL1 #(.width(32'd81)) streamToFIFO_queue(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(streamToFIFO_queue$D_IN),
					      .ENQ(streamToFIFO_queue$ENQ),
					      .DEQ(streamToFIFO_queue$DEQ),
					      .CLR(streamToFIFO_queue$CLR),
					      .D_OUT(streamToFIFO_queue$D_OUT),
					      .FULL_N(streamToFIFO_queue$FULL_N),
					      .EMPTY_N(streamToFIFO_queue$EMPTY_N));

  // rule RL_serviceMMSlave
  assign CAN_FIRE_RL_serviceMMSlave = slave_req$EMPTY_N ;
  assign WILL_FIRE_RL_serviceMMSlave = slave_req$EMPTY_N ;

  // rule RL_nextprint
  assign CAN_FIRE_RL_nextprint = 1'd1 ;
  assign WILL_FIRE_RL_nextprint = 1'd1 ;

  // rule RL_fetchpcieword
  assign CAN_FIRE_RL_fetchpcieword = streamToFIFO_queue$EMPTY_N ;
  assign WILL_FIRE_RL_fetchpcieword = streamToFIFO_queue$EMPTY_N ;

  // register currentpcieword
  assign currentpcieword$D_IN = 81'h0 ;
  assign currentpcieword$EN = 1'b0 ;

  // register dwordCounter
  assign dwordCounter$D_IN = 10'h0 ;
  assign dwordCounter$EN = 1'b0 ;

  // register fourDWord
  assign fourDWord$D_IN = 1'b0 ;
  assign fourDWord$EN = 1'b0 ;

  // register next
  assign next$D_IN = 1'd0 ;
  assign next$EN = streamToFIFO_queue$EMPTY_N ;

  // submodule rxfifo
  assign rxfifo$D_IN = streamToFIFO_queue$D_OUT ;
  assign rxfifo$ENQ = streamToFIFO_queue$EMPTY_N && rxfifo$FULL_N ;
  assign rxfifo$DEQ =
	     slave_req$EMPTY_N && !slave_req$D_OUT[80] &&
	     slave_req$D_OUT[15:8] == 8'd0 &&
	     rxfifo$EMPTY_N ;
  assign rxfifo$CLR = 1'b0 ;

  // submodule slave_req
  assign slave_req$D_IN =
	     { !mmSlave_avs_read,
	       mmSlave_avs_writedata,
	       mmSlave_avs_address,
	       mmSlave_avs_byteenable } ;
  assign slave_req$ENQ = mmSlave_avs_read || mmSlave_avs_write ;
  assign slave_req$DEQ = slave_req$EMPTY_N ;
  assign slave_req$CLR = 1'b0 ;

  // submodule streamToFIFO_queue
  assign streamToFIFO_queue$D_IN =
	     { streamSink_asi_sop,
	       streamSink_asi_eop,
	       7'd0,
	       streamSink_asi_be,
	       streamSink_asi_data } ;
  assign streamToFIFO_queue$ENQ =
	     streamSink_asi_valid && streamToFIFO_queue$FULL_N ;
  assign streamToFIFO_queue$DEQ = streamToFIFO_queue$EMPTY_N ;
  assign streamToFIFO_queue$CLR = 1'b0 ;

  // remaining internal signals
  assign response__h892 =
	     { rxfifo$D_OUT[79] ? 8'hEE : 8'h0,
	       rxfifo$D_OUT[80] ? 8'h55 : 8'h0,
	       22'b0,
	       rxfifo$D_OUT[79],
	       rxfifo$D_OUT[80],
	       rxfifo$D_OUT[71:64],
	       16'd0 } ;
  assign response__h902 = {64{rxfifo$EMPTY_N}} ;
  always@(slave_req$D_OUT or rxfifo$D_OUT or response__h892 or response__h902)
  begin
    case (slave_req$D_OUT[15:8])
      8'd0, 8'd1: v__h733 = rxfifo$D_OUT[63:0];
      8'd2: v__h733 = response__h892;
      8'd3: v__h733 = response__h902;
      default: v__h733 = 64'hDEADFACEBEEFCAFE;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        currentpcieword <= `BSV_ASSIGNMENT_DELAY 81'd0;
	dwordCounter <= `BSV_ASSIGNMENT_DELAY 10'h0;
	fourDWord <= `BSV_ASSIGNMENT_DELAY 1'd1;
	next <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (currentpcieword$EN)
	  currentpcieword <= `BSV_ASSIGNMENT_DELAY currentpcieword$D_IN;
	if (dwordCounter$EN)
	  dwordCounter <= `BSV_ASSIGNMENT_DELAY dwordCounter$D_IN;
	if (fourDWord$EN) fourDWord <= `BSV_ASSIGNMENT_DELAY fourDWord$D_IN;
	if (next$EN) next <= `BSV_ASSIGNMENT_DELAY next$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    currentpcieword = 81'h0AAAAAAAAAAAAAAAAAAAA;
    dwordCounter = 10'h2AA;
    fourDWord = 1'h0;
    next = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE) if (slave_req$EMPTY_N) $display("request");
    if (RST_N != `BSV_RESET_VALUE)
      if (slave_req$EMPTY_N && slave_req$D_OUT[80])
	$display("write %x", slave_req$D_OUT[15:8]);
    if (RST_N != `BSV_RESET_VALUE)
      if (slave_req$EMPTY_N && !slave_req$D_OUT[80])
	$display("read %x", slave_req$D_OUT[15:8]);
    if (RST_N != `BSV_RESET_VALUE)
      if (slave_req$EMPTY_N && !slave_req$D_OUT[80] &&
	  slave_req$D_OUT[15:8] == 8'd0)
	$display("trigger pcieword=%x", rxfifo$D_OUT);
    if (RST_N != `BSV_RESET_VALUE)
      $display("next=%d, rxfifo.empty=%d", next, !rxfifo$EMPTY_N);
    if (RST_N != `BSV_RESET_VALUE)
      if (streamToFIFO_queue$EMPTY_N && rxfifo$FULL_N)
	$display("PCIe word[%d] arrived as %x, swapped into %x, 4DWordTLP=%x, sof=%d, eof=%d, be.in=%x, be.swapped=%x",
		 $unsigned(dwordCounter),
		 streamToFIFO_queue$D_OUT,
		 streamToFIFO_queue$D_OUT,
		 fourDWord,
		 streamToFIFO_queue$D_OUT[80],
		 streamToFIFO_queue$D_OUT[79],
		 streamToFIFO_queue$D_OUT[71:64],
		 streamToFIFO_queue$D_OUT[71:64]);
    if (RST_N != `BSV_RESET_VALUE)
      if (streamToFIFO_queue$EMPTY_N && !rxfifo$FULL_N) $display("junked");
  end
  // synopsys translate_on
endmodule  // mkPCIePacketReceiver

