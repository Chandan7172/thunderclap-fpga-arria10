//
// Generated by Bluespec Compiler, version 2017.07.A (build 1da80f1, 2017-07-21)
//
// On Wed Jan  2 22:34:28 GMT 2019
//
//
// Ports:
// Name                         I/O  size props
// streamSource_aso_data          O    64
// streamSource_aso_valid         O     1
// streamSource_aso_sop           O     1
// streamSource_aso_eop           O     1
// streamSource_aso_be            O     8
// streamSource_aso_parity        O     8 const
// streamSource_aso_bar           O     8 const
// streamSource_aso_err           O     1 const
// mmSlave_avs_readdata           O    64
// mmSlave_avs_readdatavalid      O     1 reg
// mmSlave_avs_waitrequest        O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// streamSource_aso_ready         I     1
// mmSlave_avs_writedata          I    64 reg
// mmSlave_avs_address            I     8 reg
// mmSlave_avs_read               I     1
// mmSlave_avs_write              I     1
// mmSlave_avs_byteenable         I     8 reg
//
// Combinational paths from inputs to outputs:
//   streamSource_aso_ready -> streamSource_aso_data
//   streamSource_aso_ready -> streamSource_aso_valid
//   streamSource_aso_ready -> streamSource_aso_sop
//   streamSource_aso_ready -> streamSource_aso_eop
//   streamSource_aso_ready -> streamSource_aso_be
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkPCIePacketTransmitter(CLK,
			       RST_N,

			       streamSource_aso_ready,

			       streamSource_aso_data,

			       streamSource_aso_valid,

			       streamSource_aso_sop,

			       streamSource_aso_eop,

			       streamSource_aso_be,

			       streamSource_aso_parity,

			       streamSource_aso_bar,

			       streamSource_aso_err,

			       mmSlave_avs_readdata,

			       mmSlave_avs_readdatavalid,

			       mmSlave_avs_waitrequest,

			       mmSlave_avs_writedata,
			       mmSlave_avs_address,
			       mmSlave_avs_read,
			       mmSlave_avs_write,
			       mmSlave_avs_byteenable);
  input  CLK;
  input  RST_N;

  // action method streamSource_aso
  input  streamSource_aso_ready;

  // value method streamSource_aso_data
  output [63 : 0] streamSource_aso_data;

  // value method streamSource_aso_valid
  output streamSource_aso_valid;

  // value method streamSource_aso_sop
  output streamSource_aso_sop;

  // value method streamSource_aso_eop
  output streamSource_aso_eop;

  // value method streamSource_aso_be
  output [7 : 0] streamSource_aso_be;

  // value method streamSource_aso_parity
  output [7 : 0] streamSource_aso_parity;

  // value method streamSource_aso_bar
  output [7 : 0] streamSource_aso_bar;

  // value method streamSource_aso_err
  output streamSource_aso_err;

  // value method mmSlave_avs_readdata
  output [63 : 0] mmSlave_avs_readdata;

  // value method mmSlave_avs_readdatavalid
  output mmSlave_avs_readdatavalid;

  // value method mmSlave_avs_waitrequest
  output mmSlave_avs_waitrequest;

  // action method mmSlave_avs
  input  [63 : 0] mmSlave_avs_writedata;
  input  [7 : 0] mmSlave_avs_address;
  input  mmSlave_avs_read;
  input  mmSlave_avs_write;
  input  [7 : 0] mmSlave_avs_byteenable;

  // signals for module outputs
  wire [63 : 0] mmSlave_avs_readdata, streamSource_aso_data;
  wire [7 : 0] streamSource_aso_bar,
	       streamSource_aso_be,
	       streamSource_aso_parity;
  wire mmSlave_avs_readdatavalid,
       mmSlave_avs_waitrequest,
       streamSource_aso_eop,
       streamSource_aso_err,
       streamSource_aso_sop,
       streamSource_aso_valid;

  // inlined wires
  wire [81 : 0] fifoToStream_data$wget;
  wire fifoToStream_data$whas;

  // register currentpcieword
  reg [80 : 0] currentpcieword;
  reg [80 : 0] currentpcieword$D_IN;
  wire currentpcieword$EN;

  // register dwordCounter
  reg [9 : 0] dwordCounter;
  wire [9 : 0] dwordCounter$D_IN;
  wire dwordCounter$EN;

  // register fourDWord
  reg fourDWord;
  wire fourDWord$D_IN, fourDWord$EN;

  // register go
  reg go;
  wire go$D_IN, go$EN;

  // ports of submodule slave_req
  wire [80 : 0] slave_req$D_IN, slave_req$D_OUT;
  wire slave_req$CLR,
       slave_req$DEQ,
       slave_req$EMPTY_N,
       slave_req$ENQ,
       slave_req$FULL_N;

  // ports of submodule txfifo
  wire [80 : 0] txfifo$D_IN, txfifo$D_OUT;
  wire txfifo$CLR, txfifo$DEQ, txfifo$EMPTY_N, txfifo$ENQ, txfifo$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_nextprint,
       CAN_FIRE_RL_sendpcieword,
       CAN_FIRE_RL_serviceMMSlave,
       CAN_FIRE_mmSlave_avs,
       CAN_FIRE_streamSource_aso,
       WILL_FIRE_RL_nextprint,
       WILL_FIRE_RL_sendpcieword,
       WILL_FIRE_RL_serviceMMSlave,
       WILL_FIRE_mmSlave_avs,
       WILL_FIRE_streamSource_aso;

  // action method streamSource_aso
  assign CAN_FIRE_streamSource_aso = 1'd1 ;
  assign WILL_FIRE_streamSource_aso = 1'd1 ;

  // value method streamSource_aso_data
  assign streamSource_aso_data = fifoToStream_data$wget[63:0] ;

  // value method streamSource_aso_valid
  assign streamSource_aso_valid =
	     fifoToStream_data$whas && fifoToStream_data$wget[81] ;

  // value method streamSource_aso_sop
  assign streamSource_aso_sop = fifoToStream_data$wget[80] ;

  // value method streamSource_aso_eop
  assign streamSource_aso_eop = fifoToStream_data$wget[79] ;

  // value method streamSource_aso_be
  assign streamSource_aso_be = fifoToStream_data$wget[71:64] ;

  // value method streamSource_aso_parity
  assign streamSource_aso_parity = 8'd0 ;

  // value method streamSource_aso_bar
  assign streamSource_aso_bar = 8'd0 ;

  // value method streamSource_aso_err
  assign streamSource_aso_err = 1'd0 ;

  // value method mmSlave_avs_readdata
  assign mmSlave_avs_readdata =
	     slave_req$D_OUT[80] ?
	       64'hDEADFACEBEEFCAFE :
	       64'hEEFFC0000CB0CEFA ;

  // value method mmSlave_avs_readdatavalid
  assign mmSlave_avs_readdatavalid = slave_req$EMPTY_N ;

  // value method mmSlave_avs_waitrequest
  assign mmSlave_avs_waitrequest = !slave_req$FULL_N ;

  // action method mmSlave_avs
  assign CAN_FIRE_mmSlave_avs = 1'd1 ;
  assign WILL_FIRE_mmSlave_avs = 1'd1 ;

  // submodule slave_req
  FIFOL1 #(.width(32'd81)) slave_req(.RST(RST_N),
				     .CLK(CLK),
				     .D_IN(slave_req$D_IN),
				     .ENQ(slave_req$ENQ),
				     .DEQ(slave_req$DEQ),
				     .CLR(slave_req$CLR),
				     .D_OUT(slave_req$D_OUT),
				     .FULL_N(slave_req$FULL_N),
				     .EMPTY_N(slave_req$EMPTY_N));

  // submodule txfifo
  SizedFIFO #(.p1width(32'd81),
	      .p2depth(32'd64),
	      .p3cntr_width(32'd6),
	      .guarded(32'd0)) txfifo(.RST(RST_N),
				      .CLK(CLK),
				      .D_IN(txfifo$D_IN),
				      .ENQ(txfifo$ENQ),
				      .DEQ(txfifo$DEQ),
				      .CLR(txfifo$CLR),
				      .D_OUT(txfifo$D_OUT),
				      .FULL_N(txfifo$FULL_N),
				      .EMPTY_N(txfifo$EMPTY_N));

  // rule RL_sendpcieword
  assign CAN_FIRE_RL_sendpcieword =
	     !txfifo$EMPTY_N || !go || streamSource_aso_ready ;
  assign WILL_FIRE_RL_sendpcieword = CAN_FIRE_RL_sendpcieword ;

  // rule RL_nextprint
  assign CAN_FIRE_RL_nextprint = 1'd1 ;
  assign WILL_FIRE_RL_nextprint = 1'd1 ;

  // rule RL_serviceMMSlave
  assign CAN_FIRE_RL_serviceMMSlave = slave_req$EMPTY_N ;
  assign WILL_FIRE_RL_serviceMMSlave = slave_req$EMPTY_N ;

  // inlined wires
  assign fifoToStream_data$wget = { 1'd1, txfifo$D_OUT } ;
  assign fifoToStream_data$whas =
	     WILL_FIRE_RL_sendpcieword && txfifo$EMPTY_N && go ;

  // register currentpcieword
  always@(slave_req$D_OUT or currentpcieword)
  begin
    case (slave_req$D_OUT[15:8])
      8'd0, 8'd1:
	  currentpcieword$D_IN =
	      { currentpcieword[80:64], slave_req$D_OUT[79:16] };
      default: currentpcieword$D_IN =
		   { (slave_req$D_OUT[15:8] == 8'd2) ?
		       slave_req$D_OUT[40] :
		       currentpcieword[80],
		     (slave_req$D_OUT[15:8] == 8'd2) ?
		       slave_req$D_OUT[41] :
		       currentpcieword[79],
		     (slave_req$D_OUT[15:8] == 8'd2) ?
		       7'd0 :
		       currentpcieword[78:72],
		     (slave_req$D_OUT[15:8] == 8'd2) ?
		       slave_req$D_OUT[39:32] :
		       currentpcieword[71:64],
		     currentpcieword[63:0] };
    endcase
  end
  assign currentpcieword$EN = slave_req$EMPTY_N && slave_req$D_OUT[80] ;

  // register dwordCounter
  assign dwordCounter$D_IN = 10'h0 ;
  assign dwordCounter$EN = 1'b0 ;

  // register fourDWord
  assign fourDWord$D_IN = 1'b0 ;
  assign fourDWord$EN = 1'b0 ;

  // register go
  assign go$D_IN = slave_req$D_OUT[16] ;
  assign go$EN =
	     slave_req$EMPTY_N && slave_req$D_OUT[80] &&
	     slave_req$D_OUT[15:8] == 8'd3 ;

  // submodule slave_req
  assign slave_req$D_IN =
	     { !mmSlave_avs_read,
	       mmSlave_avs_writedata,
	       mmSlave_avs_address,
	       mmSlave_avs_byteenable } ;
  assign slave_req$ENQ = mmSlave_avs_read || mmSlave_avs_write ;
  assign slave_req$DEQ = slave_req$EMPTY_N ;
  assign slave_req$CLR = 1'b0 ;

  // submodule txfifo
  assign txfifo$D_IN = { currentpcieword[80:64], slave_req$D_OUT[79:16] } ;
  assign txfifo$ENQ =
	     slave_req$EMPTY_N && slave_req$D_OUT[80] &&
	     slave_req$D_OUT[15:8] == 8'd0 &&
	     txfifo$FULL_N ;
  assign txfifo$DEQ = fifoToStream_data$whas ;
  assign txfifo$CLR = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        currentpcieword <= `BSV_ASSIGNMENT_DELAY 81'd0;
	dwordCounter <= `BSV_ASSIGNMENT_DELAY 10'h0;
	fourDWord <= `BSV_ASSIGNMENT_DELAY 1'd1;
	go <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (currentpcieword$EN)
	  currentpcieword <= `BSV_ASSIGNMENT_DELAY currentpcieword$D_IN;
	if (dwordCounter$EN)
	  dwordCounter <= `BSV_ASSIGNMENT_DELAY dwordCounter$D_IN;
	if (fourDWord$EN) fourDWord <= `BSV_ASSIGNMENT_DELAY fourDWord$D_IN;
	if (go$EN) go <= `BSV_ASSIGNMENT_DELAY go$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    currentpcieword = 81'h0AAAAAAAAAAAAAAAAAAAA;
    dwordCounter = 10'h2AA;
    fourDWord = 1'h0;
    go = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_sendpcieword && txfifo$EMPTY_N && go)
	$display("PCIe word[%d] received from MM=%x, sent swapped=%x",
		 $unsigned(dwordCounter),
		 txfifo$D_OUT,
		 txfifo$D_OUT);
    if (RST_N != `BSV_RESET_VALUE)
      $display("go=%d, txfifo.empty=%d, txfifo.full=%d",
	       go,
	       !txfifo$EMPTY_N,
	       !txfifo$FULL_N);
    if (RST_N != `BSV_RESET_VALUE) if (slave_req$EMPTY_N) $display("request");
    if (RST_N != `BSV_RESET_VALUE)
      if (slave_req$EMPTY_N && slave_req$D_OUT[80])
	$display("write %x", slave_req$D_OUT[15:8]);
    if (RST_N != `BSV_RESET_VALUE)
      if (slave_req$EMPTY_N && slave_req$D_OUT[80] &&
	  slave_req$D_OUT[15:8] == 8'd0 &&
	  txfifo$FULL_N)
	$display("txfifo enqueued %x",
		 { currentpcieword[80:64], slave_req$D_OUT[79:16] });
    if (RST_N != `BSV_RESET_VALUE)
      if (slave_req$EMPTY_N && slave_req$D_OUT[80] &&
	  slave_req$D_OUT[15:8] == 8'd2)
	$display("Framing bits written: sofreg=%d, eofreg=%d, bereg=%x",
		 slave_req$D_OUT[40],
		 slave_req$D_OUT[41],
		 slave_req$D_OUT[39:32]);
    if (RST_N != `BSV_RESET_VALUE)
      if (slave_req$EMPTY_N && !slave_req$D_OUT[80])
	$display("read %x", slave_req$D_OUT[15:8]);
  end
  // synopsys translate_on
endmodule  // mkPCIePacketTransmitter

